import string
from CONSTANTS import *
from Projectile import *
import random
import os

class Character(pygame.sprite.Sprite):
    """This class represents the generic Character type with all general actions (movement, drawing, animations)"""
    def __init__(self, x_pos: int, y_pos: int, speed: int, char_type: string):
        pygame.sprite.Sprite.__init__(self)
        self.alive = True
        self.speed = speed # horizontal movement speed
        self.y_vel = 0     # y velocity, used to calculate jumping speed and gravity effect
        self.direction = 1 # -1 = Left, 1 = Right
        self.jump = False  # Am I currently able to jump?
        self.airborne = True
        self.flip = False # Should the image be flipped?
        self.char_type = char_type # character type... will eventually be indicated by sub class tybe

        self.energy = 100
        self.health = 100

        self.anim_list = [] # 2D list of animations. Rows indicate action being animated, cols indicate frame of animation
        self.action = 0     # Which action (row) to animate
        self.anim_index = 0 # Which frame (col) of the animation are we on
        self.update_anim = pygame.time.get_ticks() # Get current time

        for action in ACTION.keys(): # load the frames of all animations for this character type
            frames = len(os.listdir(f"img/{char_type}/{action}")) # count the number of frames for that specific animation
            action_frames = []
            for i in range(frames):
                img = pygame.image.load(f"img/{char_type}/{action}/{i}.png").convert_alpha()
                img = pygame.transform.scale(img, (BLOCK_SIZE, BLOCK_SIZE)) # Resize the image to standardize the size
                action_frames.append(img)
            self.anim_list.append(action_frames) # add animation as a row

        self.token = self.anim_list[self.action][self.anim_index] # set current image to first animation (should be frame 0 of IDLE)
        self.rect = self.token.get_rect()  # get the rectangle generated by the image for collisions and movement
        self.rect.center = (x_pos, y_pos)

    def update_action(self, new_action):
        """ Used to update which action is being performed, so that the 
        correct animation is displayed"""
        if new_action != self.action:
            # If action type has changed, reset animation variables to start
            self.action = new_action
            self.anim_index = 0
            self.update_anim = pygame.time.get_ticks()

    def update_animation(self):
        """Used to loop through the currently selected animation"""
        if pygame.time.get_ticks() - self.update_anim > ANIM_COOLDOWN: # Update animation frame based on cooldown timer
            self.anim_index = (self.anim_index + 1) % len(self.anim_list[self.action]) # advance frame index, if at the end of the animation, circle back to index 0
            self.update_anim = pygame.time.get_ticks() # reset cooldown timer
            self.token = self.anim_list[self.action][self.anim_index] # change frame

    def draw(self, screen):
        """This method is used to draw the character's current state to the screen"""
        self.update_animation()
        screen.blit(pygame.transform.flip(self.token, self.flip, False), self.rect)

    def move(self, moving_l = False, moving_r = False):
        """Enables movement in the x axis, and jumping"""
        dx = 0
        dy = 0

        if moving_l: # face left, move left
            dx = -self.speed
            self.flip = True
            self.direction = -1
        if moving_r: # face right, move right
            dx = self.speed
            self.flip = False
            self.direction = 1

        if self.jump and not self.airborne: # If I am currently able to jump and not already airborne, increase y velocity
            self.y_vel = -11
            self.jump = False
            self.airborne = True

        self.y_vel = 10 if self.y_vel + GRAVITY > 10 else self.y_vel + GRAVITY # increase downward velocity (garvity), cap at max 10
        dy += self.y_vel

        if self.rect.bottom + dy > GROUND: # check for collision with ground (will update in the future to check for any platforms)
            dy = GROUND - self.rect.bottom
            self.airborne = False

        # update position based on any changes that have happened in this function
        self.rect.x += dx
        self.rect.y += dy

    def do_action(self):
        """Currently only works for Commet. Must be separated into Commet sub class 
        and left as an abstract function for subsequent heroes to be added"""
        if self.energy > 0:
            proj_type = "hot" if random.random() > 0.5 else "cold" # choose hot or cold at random
            proj = Projectile(self.rect.centerx + (self.rect.size[0] * self.direction), self.rect.centery, self.direction, proj_type) # create the projectile based on character's current position
            projectile_group.add(proj) # add projectile to group for auto management
            self.energy -= 5


class Commet(Character):
    """This class represents the hero Commet. All Commet-specific abilities should be moved here"""
    def __init__(self, x_pos: int, y_pos: int, speed: int, char_type):
        super().__init__(x_pos, y_pos, speed, char_type)

    def update(self):
        """Commet should not check for collisions with his own projectiles"""
        self.energy = self.energy + RESTORE_RATE if self.energy + RESTORE_RATE <= FULL else FULL

class Enemy(Character):
    """This class represents a generic enemy for the time being"""
    def __init__(self, x_pos: int, y_pos: int, speed: int, char_type):
        super().__init__(x_pos, y_pos, speed, char_type)

    def update(self):
        """The enemy should check for collisions with Commet's projectiles"""
        self.energy = self.energy + RESTORE_RATE if self.energy + RESTORE_RATE <= FULL else FULL
        # self.health = self.health + RESTORE_RATE if self.health + RESTORE_RATE <= FULL else FULL
        if pygame.sprite.spritecollide(self, projectile_group, True):
            self.health -= 5
